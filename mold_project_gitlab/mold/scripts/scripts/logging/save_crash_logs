#!/bin/bash

# this is supposed to be called after an application crashed.
# optionally, an error code (or other information) can be passed as parameter.
# the calling application should set LOG_IDENTIFIER correctly if possible

SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" >/dev/null 2>&1 && pwd )"
source $SCRIPT_DIR/log_environment

# we perform the cleanup in advance on purpose. if a single logfile is larger than the limit we still have a chance to catch it,
# because it will stay until the next run of this script.
$SCRIPT_DIR/cleanup_persistent_dirs

ERROR_CODE=$1
SUFFIX=${CRASHING_APP}_$(date -u +%Y-%m-%d_%H%M%S)
REPORT_DIR=$LOG_PERSISTENT_DIR/crashreport_$SUFFIX
FILE_REPORT=$REPORT_DIR/crashreport.txt
FILE_APP_LOGS=$REPORT_DIR/crash_app_logs.log
FILE_ALL_LOGS=$REPORT_DIR/crash_all_logs.log

# Create persistent log directory
mkdir -p $REPORT_DIR

# Write crash report
echo $LOG_IDENTIFIER ended with $ERROR_CODE at $(date) > $FILE_REPORT

# Write last 100 lines of logs related to the crashed app
# We use grep instead of -t, because -t is not available on debian jessie
journalctl -o short-iso | grep -e " $LOG_IDENTIFIER[" -F --color=never | tail -n $LOG_CRASH_NUMBER_OF_RECORDS > $FILE_APP_LOGS

# Write last 100 lines of all logs
journalctl -o short-iso -n $LOG_CRASH_NUMBER_OF_RECORDS > $FILE_ALL_LOGS
